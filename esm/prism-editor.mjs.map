{"version":3,"file":"prism-editor.mjs","sources":["../code/range_selection.jsy","../code/_refresh.jsy","../node_modules/undoer/undoer.js","../code/dom.jsy","../code/editor.jsy","../code/prism-editor.jsy"],"sourcesContent":["\nexport function * relative_selection_ctxmgr(el) ::\n  const sel = el.ownerDocument.getSelection()\n  const sel_rng = 1===sel.rangeCount && sel.getRangeAt(0)\n\n  const rel_rng = as_range_relative(el, sel_rng)\n  yield rel_rng\n\n  const rng = from_range_relative(el, rel_rng)\n  if rng ::\n    sel.removeAllRanges()\n    sel.addRange(rng)\n\n\nexport function as_range_relative(el, rng) ::\n  if ! rng || ! rng.intersectsNode(el) :: return\n\n  const r_el = el.ownerDocument.createRange()\n  r_el.selectNode(el)\n\n  if -1 === rng.compareBoundaryPoints(Range.START_TO_START, r_el) ::\n    return\n  if  1 === rng.compareBoundaryPoints(Range.END_TO_END, r_el) ::\n    return\n\n  return @{}\n    start: as_range_relative_offset @ el, rng.startContainer, rng.startOffset\n    end: as_range_relative_offset @ el, rng.endContainer, rng.endOffset\n\n\nexport function from_range_relative(el, rel_rng) ::\n  if ! rel_rng :: return\n  const start = from_range_relative_offset(el, rel_rng.start)\n  const end = from_range_relative_offset(el, rel_rng.end)\n\n  if start && end ::\n    const rng = el.ownerDocument.createRange()\n    rng.setStart(start[0], start[1])\n    rng.setEnd(end[0], end[1])\n    return rng\n\n\nconst _indexOf = [].indexOf\nexport function as_range_relative_offset(el_root, el, offset) ::\n  while el !== el_root ::\n    const tip = el\n    el = el.parentNode\n    for const node of el.childNodes ::\n      if node !== tip ::\n        offset += node.textContent.length\n      else break\n  return offset\n\n\nexport function from_range_relative_offset(el_root, offset) ::\n  if offset > el_root.textContent.length ::\n    return\n\n  let tip = el_root.childNodes[0]\n  while tip ::\n    const n = tip.textContent.length\n    if n < offset ::\n      // consume leading textContent length\n      offset -= n\n      tip = tip.nextSibling\n\n    else if 3 === tip.nodeType ::\n      // TEXT_NODE with more content than our offset\n      return [tip, offset]\n\n    else ::\n      // drill down into first child\n      tip = tip.childNodes[0]\n\n","\nexport function _create_async_queue() ::\n  let _x, _q=new Set()\n  return enqueue\n\n  function enqueue(fn) ::\n    if fn :: _q.add(fn)\n    if undefined === _x && 0 !== _q.size ::\n      _x = requestAnimationFrame @ _q_step\n\n  async function _q_step() ::\n    const q_snap = _q\n    _q = new Set()\n\n    for const fn of q_snap ::\n      await fn()\n\n    _x = undefined\n    enqueue()\n\n","\nexport class Undoer {\n\n  /**\n   * @template T\n   * @param {function(T)} callback to call when undo/redo occurs\n   * @param {T=} zero the zero state for undoing everything\n   */\n  constructor(callback, zero=null) {\n    this._duringUpdate = false;\n    this._stack = [zero];\n \n    // nb. Previous versions of this used `input` for browsers other than Firefox (as Firefox\n    // _only_ supports execCommand on contentEditable)\n    this._ctrl = document.createElement('div');\n    this._ctrl.setAttribute('aria-hidden', 'true');\n    this._ctrl.style.opacity = 0;\n    this._ctrl.style.position = 'fixed';\n    this._ctrl.style.top = '-1000px';\n    this._ctrl.style.pointerEvents = 'none';\n    this._ctrl.tabIndex = -1;\n\n    this._ctrl.contentEditable = true;\n    this._ctrl.textContent = '0';\n    this._ctrl.style.visibility = 'hidden';  // hide element while not used\n\n    this._ctrl.addEventListener('focus', (ev) => {\n      // Safari needs us to wait, can't blur immediately.\n      window.setTimeout(() => void this._ctrl.blur(), 0);\n    });\n    this._ctrl.addEventListener('input', (ev) => {\n      if (!this._duringUpdate) {\n        callback(this.data);\n      }\n\n      // clear selection, otherwise user copy gesture will copy value\n      // nb. this _probably_ won't work inside Shadow DOM\n      // nb. this is mitigated by the fact that we set visibility: 'hidden'\n      const s = window.getSelection();\n      if (s.containsNode(this._ctrl, true)) {\n        s.removeAllRanges();\n      }\n    });\n  }\n\n  /**\n   * @return {number} the current stack value\n   */\n  get _depth() {\n    return +(this._ctrl.textContent) || 0;\n  }\n\n  /**\n   * @return {T} the current data\n   * @export\n   */\n  get data() {\n    return this._stack[this._depth];\n  }\n\n  /**\n   * Pushes a new undoable event. Adds to the browser's native undo/redo stack.\n   *\n   * @param {T} data the data for this undo event\n   * @param {!Node=} parent to add to, uses document.body by default\n   * @export\n   */\n  push(data, parent) {\n    // nb. We can't remove this later: the only case we could is if the user undoes everything\n    // and then does some _other_ action (which we can't detect).\n    if (!this._ctrl.parentNode) {\n      // nb. we check parentNode as this would remove contentEditable's history\n      (parent || document.body).appendChild(this._ctrl);\n    }\n\n    const nextID = this._depth + 1;\n    this._stack.splice(nextID, this._stack.length - nextID, data);\n\n    const previousFocus = document.activeElement;\n    try {\n      this._duringUpdate = true;\n      this._ctrl.style.visibility = null;\n      this._ctrl.focus();\n      document.execCommand('selectAll');\n      document.execCommand('insertText', false, nextID);\n    } finally {\n      this._duringUpdate = false;\n      this._ctrl.style.visibility = 'hidden';\n    }\n\n    previousFocus && previousFocus.focus();\n  }\n}\n","import {relative_selection_ctxmgr} from './range_selection.jsy'\nimport {_create_async_queue} from './_refresh.jsy'\nimport {Undoer} from 'undoer/undoer.js'\n\n\nexport function code_editor_dom(host, el_code, state0, opt) ::\n  _init_code_dom(el_code, opt)\n  _init_editor_api(host, el_code, state0)\n\n  const events = opt.events || code_editor_events\n  const _on_evt = bind_evt_dispatch @ events, host, opt\n  for const key of events.keys ::\n    el_code.addEventListener @ key, _on_evt\n\n  return @::\n    for const key of events.keys ::\n      el_code.removeEventListener @ key, _on_evt\n\n\n\nexport const code_editor_events = Object.freeze @:\n  keys: Object.freeze @# 'keydown', 'keyup', 'paste', 'input'\n  attrs: Object.freeze @# 'key'\n  table: Object.freeze @:\n    'evt:keydown,key:Tab'(evt, host, opt) ::\n      evt.preventDefault()\n      document.execCommand @ 'insertText', false, opt.tabs || '    '\n\n    'evt:paste'(evt, host) ::\n      evt.preventDefault()\n      const text = evt.clipboardData.getData('text/plain')\n      if text ::\n        document.execCommand @ 'insertText', false, text\n        host.dirty()\n\n    'evt:input': bind_evt_editor_input()\n\nexport function bind_evt_dispatch(events, ... ex_args) ::\n  const {table, attrs} = events\n  return @\\ evt ::\n    const evec = @[] `evt:${evt.type}`, ... @\n      attrs\n        .map @ k => `${k}:${evt[k]}`\n        .filter @ Boolean\n\n    for let i=evec.length; i>0; i-- ::\n      const fn = table[evec.slice(0,i)]\n      if fn ::\n        return fn(evt, ... ex_args)\n\nexport function bind_evt_editor_input() ::\n  // specialized input event to work in concert with Undoer\n  const wset = new WeakSet()\n  return @\\ evt, host ::\n    if wset.has(host) ::\n      return\n\n    wset.add(host)\n    try ::\n      const src_code = host.src_code\n      for const _ of host.with_selection() ::\n        document.execCommand @ 'undo', false\n        host.raw_src_code = src_code\n        host.dirty()\n    finally ::\n      wset.delete(host)\n\n\n\nexport function _init_editor_api(host, el_code, state_tip) ::\n  let _undoer = new Undoer @ _do_undo, state_tip\n  function _do_undo(prev_state) ::\n    const save = _undoer\n    _undoer = null\n    try :: host.restoreState(prev_state)\n    finally :: _undoer = save\n\n\n  const q_async = _create_async_queue()\n  return Object.assign @ host, @{}\n    *with_selection() ::\n      for const _ of relative_selection_ctxmgr(el_code) ::\n        yield\n\n    dirty() ::\n      q_async @ host.refresh\n\n    refresh() ::\n      for const _ of host.with_selection() ::\n        host.src_code = host.src_code + ''\n\n    _emit_src_code(el, new_state, shape=['lang', 'src_code']) ::\n      if _state_equal(new_state, state_tip, shape) ::\n        return\n\n      state_tip = new_state\n      if null !== _undoer ::\n        _undoer.push @ new_state, el\n\n      const evt = new CustomEvent @ 'src_code', @{}\n        bubbles: true, detail: new_state\n\n      ;(el || el_code).dispatchEvent(evt)\n\n\nfunction _state_equal(a,b, shape) ::\n  for const k of shape ::\n    if a[k] !== b[k] ::\n      return false\n  return true\n\n\nconst _ed_attrs = @{}\n  contentEditable: true\n  spellcheck: false\n\nconst _ed_style = @{}\n  outline: 'none'\n  overflowWrap: 'break-word'\n  overflowY: 'auto'\n  resize: 'vertical'\n  whiteSpace: 'pre-wrap'\n\nexport function _init_code_dom(el_code, opt) ::\n  const attrs = {... _ed_attrs, ... opt.attrs || {}} \n  for const k in attrs ::\n    el_code.setAttribute(k, attrs[k])\n\n  Object.assign @ el_code.style,\n    {... _ed_style, ... opt.style || {}}\n\n","import {code_editor_dom} from './dom.jsy'\n\nexport default bindCodeEditor\nexport function bindCodeEditor(fn_src_highlight, opt = {}) ::\n  opt = @{} ... opt || {}\n\n  class CodeEditor extends HTMLElement ::\n    connectedCallback() ::\n      const src_code = this.textContent\n        .replace(/^\\s*\\r?\\n/, '')\n      this.textContent = ''\n      const state0 = @{} src_code, lang: this.lang\n\n      const el = this._el_code = this._init_dom(this.ownerDocument)\n      this._disconnect = code_editor_dom(this, el, state0, opt)\n      this.src_code = src_code\n\n    disconnectedCallback() ::\n      if this._disconnect ::\n        this._disconnect()\n\n    _init_dom(odoc) ::\n      const el_code = odoc.createElement('code')\n      const el_pre = odoc.createElement('pre')\n      el_pre.appendChild(el_code)\n      this.appendChild(el_pre)\n      return el_code\n\n\n    static get observedAttributes() ::\n      return @[] 'lang'\n    attributeChangedCallback() ::\n      this.dirty()\n\n    dirty() ::\n    refresh() ::\n\n    get lang() :: return this.getAttribute('lang')\n    set lang(lang) :: this.setAttribute('lang', lang)\n\n    get raw_src_code() ::\n      return this._el_code.textContent\n    set raw_src_code(src_code) ::\n      const {_el_code: el, lang} = this\n      el.innerHTML = ''\n      el.textContent = src_code\n\n      if lang ::\n        const cls_lang = `language-${lang}`\n        el.className = cls_lang || ''\n        el.parentNode.className = cls_lang || ''\n\n      this._emit_src_code @ this, {src_code, lang}\n\n    get src_code() ::\n      return this._el_code.textContent\n    set src_code(src_code) ::\n      this.raw_src_code = src_code\n      fn_src_highlight(this._el_code)\n\n    restoreState({lang, src_code}) ::\n      this.lang = lang\n      this.src_code = src_code\n\n  return CodeEditor\n\n","import {bindCodeEditor} from './editor.jsy'\n\nexport const PrismCodeEditor = bindCodeEditor(Prism.highlightElement)\ncustomElements.define @ 'prism-code-editor', PrismCodeEditor\n\n"],"names":[],"mappings":"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"}