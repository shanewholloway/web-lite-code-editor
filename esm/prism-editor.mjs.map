{"version":3,"file":"prism-editor.mjs","sources":["../code/range_selection.jsy","../code/dom.jsy","../code/_refresh.jsy","../code/editor.jsy","../code/prism-editor.jsy"],"sourcesContent":["\nexport function * relative_selection_ctxmgr(el) ::\n  const sel = el.ownerDocument.getSelection()\n  const sel_rng = 1===sel.rangeCount && sel.getRangeAt(0)\n\n  const rel_rng = as_range_relative(el, sel_rng)\n  yield rel_rng\n\n  const rng = from_range_relative(el, rel_rng)\n  if rng ::\n    sel.removeAllRanges()\n    sel.addRange(rng)\n\n\nexport function as_range_relative(el, rng) ::\n  if ! rng || ! rng.intersectsNode(el) :: return\n\n  const r_el = el.ownerDocument.createRange()\n  r_el.selectNode(el)\n\n  if -1 === rng.compareBoundaryPoints(Range.START_TO_START, r_el) ::\n    return\n  if  1 === rng.compareBoundaryPoints(Range.END_TO_END, r_el) ::\n    return\n\n  return @{}\n    start: as_range_relative_offset @ el, rng.startContainer, rng.startOffset\n    end: as_range_relative_offset @ el, rng.endContainer, rng.endOffset\n\n\nexport function from_range_relative(el, rel_rng) ::\n  if ! rel_rng :: return\n  const start = from_range_relative_offset(el, rel_rng.start)\n  const end = from_range_relative_offset(el, rel_rng.end)\n\n  if start && end ::\n    const rng = el.ownerDocument.createRange()\n    rng.setStart(start[0], start[1])\n    rng.setEnd(end[0], end[1])\n    return rng\n\n\nconst _indexOf = [].indexOf\nexport function as_range_relative_offset(el_root, el, offset) ::\n  while el !== el_root ::\n    const tip = el\n    el = el.parentNode\n    for const node of el.childNodes ::\n      if node !== tip ::\n        offset += node.textContent.length\n      else break\n  return offset\n\n\nexport function from_range_relative_offset(el_root, offset) ::\n  if offset > el_root.textContent.length ::\n    return\n\n  let tip = el_root.childNodes[0]\n  while tip ::\n    const n = tip.textContent.length\n    if n < offset ::\n      // consume leading textContent length\n      offset -= n\n      tip = tip.nextSibling\n\n    else if 3 === tip.nodeType ::\n      // TEXT_NODE with more content than our offset\n      return [tip, offset]\n\n    else ::\n      // drill down into first child\n      tip = tip.childNodes[0]\n\n","import {relative_selection_ctxmgr} from './range_selection.jsy'\n\nconst _ed_attrs = @{}\n  contentEditable: true\n  spellcheck: false\n\nconst _ed_style = @{}\n  outline: 'none'\n  overflowWrap: 'break-word'\n  overflowY: 'auto'\n  resize: 'vertical'\n  whiteSpace: 'pre-wrap'\n\nexport function init_dom_editor(host, el, src_code0, opt) ::\n  const attrs = {... _ed_attrs, ... opt.attrs || {}} \n  for const k in attrs ::\n    el.setAttribute(k, attrs[k])\n\n  Object.assign @ el.style,\n    {... _ed_style, ... opt.style || {}}\n\n\n  const ktbl = @{}\n    'evt keydown Tab'(evt) ::\n      evt.preventDefault()\n      document.execCommand @ 'insertText', false, opt.tabs || '    '\n\n  function ktbl_evt(evt) ::\n    const fn = ktbl[`evt ${evt.type} ${evt.key}`]\n    if fn :: fn(evt, host)\n\n  el.addEventListener @ 'keydown', ktbl_evt\n  el.addEventListener @ 'keyup', ktbl_evt\n  el.addEventListener @ 'input', @:: host.dirty()\n\n  el.addEventListener @ 'paste', @\\ evt ::\n    evt.preventDefault()\n    const text = evt.clipboardData.getData('text/plain')\n    document.execCommand('insertText', false, text)\n    host.dirty()\n\n\n  host.refresh = @::\n    for const _ of relative_selection_ctxmgr(el) ::\n      host.src_code = host.src_code + ''\n\n  host._emit_src_code = @::\n    const {src_code} = host\n    if src_code != src_code0 ::\n      src_code0 = src_code\n      host.dispatchEvent @\n        new CustomEvent @ 'src_code', \n          @{} detail: src_code\n\n","\nexport function _create_async_queue() ::\n  let _x, _q=new Set()\n  return enqueue\n\n  function enqueue(fn) ::\n    if fn :: _q.add(fn)\n    if undefined === _x && 0 !== _q.size ::\n      _x = requestAnimationFrame @ _q_step\n\n  async function _q_step() ::\n    const q_snap = _q\n    _q = new Set()\n\n    for const fn of q_snap ::\n      await fn()\n\n    _x = undefined\n    enqueue()\n\n","import {init_dom_editor} from './dom.jsy'\nimport {_create_async_queue} from './_refresh.jsy'\n\n\nexport default bindCodeEditor\nexport function bindCodeEditor(fn_src_highlight, opt = {}) ::\n  opt = @{} ... opt || {}\n  const _q_async = _create_async_queue()\n\n  class CodeEditor extends HTMLElement ::\n    connectedCallback() ::\n      let src_code = this.textContent\n        .replace(/^(\\s*\\r?\\n)+/, '')\n        .trimEnd()\n\n      this.textContent = ''\n\n      const el = this._el_code = this._init_dom(this.ownerDocument)\n      init_dom_editor(this, el, src_code, opt)\n      this.src_code = src_code\n\n    _init_dom(odoc) ::\n      const el_code = odoc.createElement('code')\n      const el_pre = odoc.createElement('pre')\n      el_pre.appendChild(el_code)\n      this.appendChild(el_pre)\n      return el_code\n\n\n    static get observedAttributes() ::\n      return @[] 'lang'\n    attributeChangedCallback() ::\n      this.dirty()\n\n    dirty() :: _q_async @ this.refresh\n\n    get lang() :: return this.getAttribute('lang')\n    set lang(lang) :: this.setAttribute('lang', lang)\n\n    get src_code() ::\n      return this._el_code.textContent\n    set src_code(src_code) ::\n      const {_el_code: el, lang} = this\n      el.innerHTML = ''\n      el.textContent = src_code\n\n      if lang ::\n        const cls_lang = `language-${lang}`\n        el.className = cls_lang || ''\n        el.parentNode.className = cls_lang || ''\n\n      _q_async @ this._emit_src_code\n      fn_src_highlight(el)\n\n\n  return CodeEditor\n\n","import {bindCodeEditor} from './editor.jsy'\n\nexport const PrismCodeEditor = bindCodeEditor(Prism.highlightElement)\ncustomElements.define @ 'prism-code-editor', PrismCodeEditor\n\n"],"names":[],"mappings":";EAEE;EACA;;EAEA;EACA;;EAEA;MACE;IACA;IACA;;;;MAIC,oCAAoC;;EAEvC;EACA;;MAEG;IACD;MACC;IACD;;EAEF;IACE,gCAAiC;IACjC,8BAA+B;;;;MAI9B,YAAY;EACf;EACA;;MAEE;IACA;IACA;IACA;IACA;;SAKG;IACH;IACA;SACG;UACC;QACA;;EAEN;;;;MAIE;IACA;;EAEF;SACK;IACH;QACE;;MAEA;MACA;;aAEK;;MAEL;;;;MAIA;;ACtEN;EACE;EACA;;AAEF;EACE,SAAS;EACT,cAAc;EACd,WAAW;EACX,QAAQ;EACR,YAAY;;;EAGZ;OACG;IACD;;EAEF,cAAe;IACb;;;EAGF;IACE,iBAAiB;MACf;MACA,qBAAuB,YAAY,qBAAqB;;EAE5D;IACE,gBAAgB,OAAO,SAAS,GAAG,QAAQ,CAAC;QAC1C,KAAM;;EAEV,oBAAqB,SAAU;EAC/B,oBAAqB,OAAQ;EAC7B,oBAAsB,OAAO,UAAK;;EAElC,oBAAqB,OAAQ;IAC3B;IACA,uCAAuC,YAAY;IACnD,qBAAqB,YAAY;IACjC;;;EAGF;SACK;MACD,gCAAgC;;EAEpC;IACE;QACE;MACA;MACA;QACE,gBAAiB,UAAW;WACvB;;;EClDX;EACA;;EAEA;QACI,KAAM;QACN;MACA,2BAA4B;;EAEhC;IACE;IACA;;SAEG;MACD;;IAEF;IACA;;;ECZF,MAAS;EACT;;EAEA;IACE;MACE;iBACW,cAAc,EAAE,EAAE;;;MAG7B,mBAAmB;;MAEnB;MACA;MACA;;IAEF;MACE,mCAAmC,MAAM;MACzC,kCAAkC,KAAK;MACvC;MACA;MACA;;;IAGF;MACE,QAAU;IACZ;MACE;;IAEF,SAAU,SAAW;;IAErB,YAAa,yBAA0B,MAAM;IAC7C,gBAAiB,kBAAmB,MAAM;;IAE1C;MACE;IACF;MACE;MACA,eAAe;MACf;;UAEE;QACA,iBAAiB,YAAY,KAAK;QAClC,2BAA2B;QAC3B,sCAAsC;;MAExC,SAAU;MACV;;;EAGJ;;;ACpDF,sBAAuB,mBAAoB;;;;"}